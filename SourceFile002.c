#pragma config(Sensor, in7,    rightLineFollower, sensorReflection)
#pragma config(Sensor, in8,    leftLineFollower, sensorReflection)
#pragma config(Sensor, dgtl1,  estop,          sensorTouch)
#pragma config(Sensor, dgtl2,  button,         sensorTouch)
#pragma config(Sensor, dgtl3,  sonar,          sensorSONAR_mm)
#pragma config(Motor,  port1,           drive,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           steer,         tmotorServoStandard, openLoop)
#pragma config(DatalogSeries, 0, "right", Sensors, Sensor, in7, 50)
#pragma config(DatalogSeries, 1, "left", Sensors, Sensor, in8, 50)
#pragma config(DatalogSeries, 2, "Deg", Motors, MotorPower, port2, 50)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task stop(){
	while(true){
		if(SensorValue[estop]==1){
			stopAllTasks();
		}
	}
}


task main()
{
	//Intitialized stuff
	startTask(stop);

	int test[] = {1950,3000};  //default values that are changed during calibration
	int turnRange = 60; //Max degree turn
	int speed = -35;  //Max speed of robot
	int servoOffset = -40; //Servo is misaligned; -40 makes it completely straight.
	int minThreshold = 0; //Inititialize error between left and right sensors. (Usually marginal)
	//minThreshold is also found during calibration stage.

	bool start = false;

	if(!start){ //the following loop calibrates the values for white background and black line.
		waitInMilliseconds(200);
		while(true)if(SensorValue(button)==1) break;

		test[0]=(SensorValue(rightLineFollower)+SensorValue(leftLineFollower))/2;
		minThreshold = SensorValue(rightLineFollower)-SensorValue(leftLineFollower);
		setServo(steer,-80);
		waitInMilliseconds(200);
		while(true)if(SensorValue(button)==1) break;

		test[1]=(SensorValue(rightLineFollower)+SensorValue(leftLineFollower))/2;
		setServo(steer,80);

	}

	int maxDiff = test[1]-test[0];  //Difference between black and white for percentage checks later on
	//_____________________________________________________
	//while(!start){
	//	if(SensorValue(button)==1){
	//		if(moveOn==true){
	//			test[1]=(SensorValue(rightLineFollower)+SensorValue(leftLineFollower))/2;
	//			setServo(steer,80);
	//			waitInMilliseconds(1000);
	//			while(true){
	//				if(SensorValue(button)==1){
	//					start=true;
	//				}
	//			}
	//		}
	//		test[0]=(SensorValue(rightLineFollower)+SensorValue(leftLineFollower))/2;
	//		setServo(steer,-80);
	//		moveOn = true;
	//		waitInMilliseconds(1000);
	//	}
	//}
	//setServo(steer,-41);
	//_____________________________________________________
	waitInMilliseconds(1000);
	while(true){//until button pressed, stay here.
		if(SensorValue(button)==1){
			setServo(steer,-40);
			waitInMilliseconds(100);
			start=true;
			break;
		}
	}
	while(start){ //Actual drive code
		startMotor(drive, speed);

		if(SensorValue(in7)>test[1]-200&&SensorValue(in8)>test[1]-200){ // if the inputed values from calibration (shows if robot encounters an intersection) are in this range, stop for a bit
			startMotor(drive, 0);
			waitInMilliseconds(5998);
			while(SensorValue(in7)>test[1]-200&&SensorValue(in8)>test[1]-200){
				setServo(steer,-40);
				startMotor(drive, speed);
			}
		}
		//_____________________________________________________
		//	else if(SensorValue(in7)>2700){
		//		startMotor(drive, speed-10);
		//	setServo(steer,50);
		//	waitInMilliseconds(50);
		//	}else if(SensorValue(in8)>2700){
		//	setServo(steer,-105);
		//		startMotor(drive, speed-10);
		//		waitInMilliseconds(50);
		//	}else{
		//	setServo(steer,-40);
		//		startMotor(drive, speed);
		//	}


		//int leftPerc = (((float) SensorValue[leftLineFollower] - test[0])/(test[1]-test[0]))*100;
		//int rightPerc = (((float) SensorValue[rightLineFollower] - test[0])/(test[1]-test[0]))*100;

		//int percSum = rightPerc-leftPerc;
		//int turnDeg = (percSum/100*(turnRange+offset));
		//setServo(steer,turnDeg);


		//writeDebugStream(printf(test[0]));
		//writeDebugStream(test[1]);
    //_____________________________________________________
		int diff = SensorValue[rightLineFollower]-SensorValue[leftLineFollower]-minThreshold; //difference (not abs) between right and left sensors. This is used to calculate how much it should turn to fix the difference.
		int turnPerc = (diff*100)/maxDiff; //Calculate offset
		if(turnPerc>20||turnPerc<-20){ //slow down motors for more precise turning.
			startMotor(drive, speed-20);
		}
		int turnDeg = turnPerc*(turnRange)/100+servoOffset; //Scales turning in relation to turn range.
		setServo(steer,turnDeg); //Sets servo at current degree.


		if(SensorValue(sonar)<200){ //Checks distance to see if it should stop.
			while(SensorValue(sonar)<200){
				startMotor(drive, 0);
			}
		}

		waitInMilliseconds(50);
	}


}
